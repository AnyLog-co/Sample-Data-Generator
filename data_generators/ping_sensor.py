"""
The following is data is based on historical data generated by Lite San Leandro for Ping
"""
import os
import random
import sys
import time

ROOT_PATH = os.path.dirname(os.path.abspath(__file__)).rsplit('data_generators', 1)[0]
PROTOCOLS = os.path.join(ROOT_PATH, 'protocols')
sys.path.insert(0, PROTOCOLS)
from support import generate_timestamp

PING_DATA = {
        'ADVA FSP3000R7': {
            'parentelement': '62e71893-92e0-11e9-b465-d4856454f4ba',
            'webid': 'F1AbEfLbwwL8F6EiShvDV-QH70AkxjnYuCS6RG0ZdSFZFT0ugnMRtEzvxdFojNpadLPwI4gWE9NUEFTUy1MSVRTTFxMSVRTQU5MRUFORFJPXDc3NyBEQVZJU1xQT1AgUk9PTVxBRFZBIEZTUDMwMDBSN3xQSU5H',
            'min_value': 0,
            'max_value': 4
        },
        'Ubiquiti OLT': {
            'parentelement': 'd515dccb-58be-11ea-b46d-d4856454f4ba',
            'webid': 'F1AbEfLbwwL8F6EiShvDV-QH70Ay9wV1b5Y6hG0bdSFZFT0ugxACfpGU7d1ojPpadLPwI4gWE9NUEFTUy1MSVRTTFxMSVRTQU5MRUFORFJPXDc3NyBEQVZJU1xQT1AgUk9PTVxVQklRVUlUSSBPTFR8UElORw',
            'min_value': 0,
            'max_value': 49
        },
        'VM Lit SL NMS': {
            'parentelement': '1ab3b14e-93b1-11e9-b465-d4856454f4ba',
            'webid': 'F1AbEfLbwwL8F6EiShvDV-QH70ATrGzGrGT6RG0ZdSFZFT0ugQW05a2rwdFojNpadLPwI4gWE9NUEFTUy1MSVRTTFxMSVRTQU5MRUFORFJPXDc3NyBEQVZJU1xQT1AgUk9PTVxGLk8gTU9OSVRPUklORyBTRVJWRVJcVk0gTElUIFNMIE5NU3xQSU5H',
            'min_value': 0,
            'max_value': 11
        },
        'Catalyst 3500XL': {
            'parentelement': '68ae8bef-92e1-11e9-b465-d4856454f4ba',
            'webid': 'F1AbEfLbwwL8F6EiShvDV-QH70A74uuaOGS6RG0ZdSFZFT0ug4FckGTrxdFojNpadLPwI4gWE9NUEFTUy1MSVRTTFxMSVRTQU5MRUFORFJPXDc3NyBEQVZJU1xQT1AgUk9PTVxDQVRBTFlTVCAzNTAwWEx8UElORw',
            'min_value': 0,
            'max_value': 49
        },
        'GOOGLE_PING': {
            'parentelement': 'f0bd0832-a81e-11ea-b46d-d4856454f4ba',
            'webid': 'F1AbEfLbwwL8F6EiShvDV-QH70AMgi98B6o6hG0bdSFZFT0ugPdQ3gcXLd1ojPpadLPwI4gWE9NUEFTUy1MSVRTTFxMSVRTQU5MRUFORFJPXDc3NyBEQVZJU1xHT09HTEVfUElOR3xQSU5H',
            'min_value': 2,
            'max_value': 37
        },
}

def get_ping_data(timezone:str, sleep:float, repeat:int)->list:
    """
    Generate the ping_value per device - based on data originally from Lit San Leandro
    :args:
        timezone:str - timezone for generated timestamp(s)
        sleep:float - wait time between each row
        repeat:int - number of times to repeat process
    :param:
        data_set:list - list of data sets
    :sample:
      {
         "device_name": "Catalyst 3500XL",
         "parentelement": "68ae8bef-92e1-11e9-b465-d4856454f4ba",
         "timestamp": "2020-12-08 02:20:11.024002",
         "value": 1,
         "webid": "F1AbEfLbwwL8F6EiShvDV-QH70A74uuaOGS6RG0ZdSFZFT0ug4FckGTrxdFojNpadLPwI4gWE9NUEFTUy1MSVRTTFxMSVRTQU5MRUFORFJPXDc3NyBEQVZJU1xQT1AgUk9PTVxDQVRBTFlTVCAzNTAwWEx8UElORw"
      }
    :return:
      data dict based on information generated by PERCENTAGECPU_DATA
    """
    data_sets = []

    for i in range(repeat):
        device_name = random.choice(list(PING_DATA.keys()))
        sub_value = random.choice(range(PING_DATA[device_name]['min_value'], PING_DATA[device_name]['max_value']))
        rand_val = random.random()
        if PING_DATA[device_name]['min_value'] <= sub_value + rand_val <= PING_DATA[device_name]['max_value']:
            value = round(sub_value + rand_val, 2)
        elif PING_DATA[device_name]['min_value'] <= sub_value - rand_val <= PING_DATA[device_name]['max_value']:
            value = round(sub_value - rand_val, 2)
        elif PING_DATA[device_name]['min_value'] <= rand_val - sub_value <= PING_DATA[device_name]['max_value']:
            value = rand_val - sub_value
        else:
            value = sub_value
        data_sets.append(
            {
                'timestamp': generate_timestamp(timezone=timezone),
                'device_name': device_name,
                'parentelement': PING_DATA[device_name]['parentelement'] ,
                'webid': PING_DATA[device_name]['webid'] ,
                'value': value
           }
        )
        time.sleep(sleep)

    return data_sets


if __name__ == '__main__':
    print(get_ping_data(sleep=1, repeat=10))

