import base64
import datetime
import hashlib
import json
import os
import random
import sys
import time
import uuid

# ROOT_PATH = os.path.dirname(os.path.abspath(__file__)).split('data_generators')[0]
# PROTOCOLS = os.path.join(ROOT_PATH, 'publish_protocols')
# sys.path.insert(0, PROTOCOLS)


def __read_image(file_name:str, exception:bool=False)->(bool, bytes):
    """
    Get content in file as binary
    :args:
        file_name:str - file path
        exception:bool - whether or not to write exceptions
    :params:
        status:bool
        file_data:bytes - content in file read as binary
        full_path:str - full path of file_name
    :return:
        status, file_data
    """
    status = True
    file_data = None
    try:
        with open(file_name, 'rb') as fb:
            try:
                file_data = fb.read()
            except Exception as error:
                if exception is True:
                    print(f'Failed to read content as binary from {file_name} (Error: {error})')
                status = False
    except Exception as error:
        if exception is True:
            print(f'Failed to binary-open {file_name} (Error: {error})')
        status = False

    return status, file_data


def __convert_base64(file_data:bytes, exception:bool)->(bool, str):
    """
    Convert bytes to ASCII string
    :args:
        file_data:bytes - bytes content generated by __read_image
        exception:bool - whether or not to print exception(s)
    :params:
        status:bool
        base64_bytes:bytes - encoded file_data
        base64_msg:string - encode file_data (base64_bytes) as string
    :return:
        status, base64_msg
    """
    status = True
    base64_bytes = None
    base64_msg = None
    try:
        base64_bytes = base64.b64encode(file_data)
    except Exception as error:
        if exception is True:
            print(f'Failed to encode file data (Error: {error})')
        status = False
    if status is True and isinstance(base64_bytes, bytes):
        try:
            base64_msg = base64_bytes.decode('ascii')
        except Exception as error:
            if exception is True:
                print(f'Failed to convert encoded message to ASCII based value (Error: {error})')
            status = False

    return status, base64_msg


def __generate_string_hash(file_name:str, data:str)->str:
    """
    based on file_name + data generate hash value
    :args:
        file_name:str - file used to generate has value
        data:str - content in file
    :params:
        str_hash:hashlib.Hash - generated hash value
    :return:
        hash value as UUID
    """
    str_hash = hashlib.md5()
    if file_name:
        # Prefixed data can be dbms name and table name that are considered in the hash
        str_hash.update(file_name.encode())  # Update the hash with the prefix data+

    str_hash.update(data.encode())  # Update the hash
    return str(uuid.UUID(str_hash.hexdigest()))


def __media_type(file_suffix:str)->str:
    """
    Generate media type based on file suffix
    :args:
        file_suffix:str - file suffix
    :params:
        suffix_value:str - based on file suffix generated suffix
    :return:
        suffix_value
    """
    suffix_value = 'unknown'
    if file_suffix == 'png':
        suffix_value = 'image/png'
    elif file_suffix in ['jpg', 'jpeg']:
        suffix_value = 'image/jpeg'
    elif file_suffix == 'mp4':
        suffix_value = 'video/mp4'

    return suffix_value


def create_data(process_id:str, file_name:str, binary_file:str, device_name:str="anylog-data-generator",
                start_ts:str=datetime.datetime.utcnow().strftime('%Y-%m-%dT%H:%M:%S.%fZ'),
                end_ts:str=(datetime.datetime.utcnow() + datetime.timedelta(seconds=5)).strftime('%Y-%m-%dT%H:%M:%S.%fZ'),
                profile_name="anylog-video-generator", num_cars:int=0, speed:float=0)->dict:
    """
    Given the user information, create a JSON object
    :args:
        process_id:str - generated UUID process
        files_dict:dict - content to store
        device_name:str - name of device data is coming from
        profile_name:str - name of device profile data is coming from
    :params:
        data:dict - placeholder for JSON object to be stored in AnyLog
        file_name:str - file name without path
    :return:
        data
    :sample json:
    {
        "apiVersion": "v2",
        "id": "6b055b44-6eae-4f5d-b2fc-f9df19bf42cf",
        "deviceName": "anylog-data-generator",
        "origin": 1660163909,
        "profileName": "anylog-video-generator",
        "readings": [{
            "start_ts": "2022-01-01 00:00:00",
            "end_ts": "2022-01-01 00:00:05",
            "binaryValue": "AAAAHGZ0eXBtcDQyAAAAAWlzb21tcDQxbXA0MgADWChtb292AAAAbG12aGQAAAAA3xnEUt8ZxFMAAHUwAANvyQABAA",
            "mediaType": "video/mp4",
            "origin": 1660163909,
            "profileName": "traffic_data",
            "resourceName": "OnvifSnapshot",
            "valueType": "Binary",
            "num_cars": 5,
            "speed": 65.3
        }],
        "sourceName": "OnvifSnapshot"
    }
    """
    data = {
        "apiVersion": "v2",
        "id": process_id,
        "deviceName": device_name,
        "origin": int(time.time()),
        "profileName": profile_name,
        "readings": [],
        "sourceName": "OnvifSnapshot"
    }

    # file_name = file_name.
    data['readings'].append({
        "timestamp": start_ts.strftime('%Y-%m-%dT%H:%M:%S.%fZ'),
        "start_ts": start_ts.strftime('%Y-%m-%dT%H:%M:%S.%fZ'),
        "end_ts": end_ts.strftime('%Y-%m-%dT%H:%M:%S.%fZ'),
        "binaryValue": binary_file,
        "deviceName": file_name.split('.')[0],
        "id": __generate_string_hash(file_name=file_name, data=binary_file),
        "mediaType": __media_type(file_suffix=file_name.rsplit('.', 1)[-1]),
        "origin": int(time.time()),
        "profileName": file_name.split('.')[1],
        "resourceName": "OnvifSnapshot",
        "valueType": "Binary",
        "num_cars": num_cars,
        "speed": speed
    })

    return data

def image_processing(file_name:str, exception:bool=False)->dict:
    """
    Given image file(s), read information and store into dictionary
    :args:
        file_name:str - (comma seperated list of) file name(s)
        exception:bool - whether or not to print exception(s) to screen
    :params:
        files:dict - dictionary of (full path) file names + raw data as string binary
    :return:
        files
    """
    binary_file = None

    status, file_data = __read_image(file_name=file_name, exception=exception)
    if status is False or file_data is None:
        print(f'Failed to to process file {file_name}')
    elif isinstance(file_data, bytes):
        status, base64_msg = __convert_base64(file_data=file_data, exception=exception)
        if status is True and isinstance(base64_msg, str):
            binary_file = base64_msg

    return status, binary_file


def main(process_id:str, file_name:str, device_name:str='anylog-data-generator',
         profile_name:str='anylog-video-generator', start_ts:datetime.datetime=datetime.datetime.utcnow(),
         end_ts:datetime.datetime=datetime.datetime.utcnow(), speed:float=0, cars:int=0,  exception:bool=False)->dict:
    """
    Main for processing files of vide or image type
    :args:
        process_id:uuid.UUID - UUID for process
        file_name:str - file(s) to store in AnyLog. Use comma to send multiple files
        device_name:str - name of device data is coming from
        profile_name:str - name of device profile data is coming from
        exception:bool - whether or not to print exceptions to screen
    :params:
        file_data:dict - content from image_processing
        data:dict - JSON object based on file_data
    :return:
        dictionary of JSON based on file_data
    """

    file_name_only = file_name.split('/')[-1].split('\\')[-1]
    full_file_path = os.path.expandvars(os.path.expanduser(file_name))
    if not os.path.isfile(full_file_path):
        print(f'Failed to locate {fn}')
    else:
        status, binary_file = image_processing(file_name=full_file_path, exception=exception)

        data = create_data(process_id=process_id, binary_file=binary_file, file_name=file_name_only, device_name=device_name,
                           start_ts=start_ts, end_ts=end_ts, profile_name=profile_name, num_cars=cars, speed=speed)

    return data


